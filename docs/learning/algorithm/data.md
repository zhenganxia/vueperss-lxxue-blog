### 数据结构
+ 数组
+ 栈
+ 队列
+ 链表
+ 树（本系列只讲二叉树）
+ 哈希表
+ 堆

1. 数组：JavaScript中的数组，不过多讲解；<br/>
2. 栈：先进后出(LIFO，Last In First Out)的特点，JavaScript中使用数组模拟，用到的方法是push和pop；<br/>
3. 队列：先进先出（FIFO，First In First Out）的特点，JavaScript中使用数组模拟，用到的方法是push和shift；<br/>
4. 链表：一组任意存储单元用来存储线性表的数据元素，一个对象中存储着本身的值和下一个元素的地址。这些元素在内存中是离散的。<br/>
5. 二叉树：二叉树是一种典型的树状结构，它可以没有根节点，作为一颗空树存在；如果根节点不为空，它必须有根节点、左子树、又子树组成。<br/>
6. 哈希表（Hash Table，也叫散列表）：是根据键（Key）而直接访问在内存存储位置的数据结构。哈希表通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。<br/>
这个映射函数称做哈希函数，存放记录的数组称做哈希表。<br/>
7. 堆：的底层是一颗完全二叉树。

### 时间复杂度与空间复杂度

#### 时间复杂度
#### 例子1：
```js
function repeat (arr) {
    const len = arr.length;
    for(let i = 0; i < len; i++) {
        console.log(arr[i]);
    }
}
```
首先，repeat函数中第一行代码，执行了1次
```js
const len = arr.length;
```
其次，循环体中循环了n次
```js
console.log(arr[i]);
```
for循环跑了n次，因此这条语句被执行了n次。

循环体的几个部分拆开来看，首先是 i 的初始化语句：
```js
let i = 0;
```
初始化执行性一次，所以它只会被执行一次。

接着是
```js
i < len;
```
在for循环中，判断语句会多执行一次，判断条件是否满足，因此这条语句会被执行n + 1次。

下面是 i++ 这条语句，毫无疑问随for循环执行了n次

假设把执行的总数设为T(n)，那么repeat函数执行总数为：
```js
T(n) = 1 + 1 + (n + 1) + n + n = 3n + 3
```

#### 例子2

如果是双层循环，规模为 n * n ，会执行多少次呢，看下面的例子：
```js
function repeat (arr) {
    const len1 = arr.length;
 
    for(let i = 0; i < len1; i++) {
        const len2 = arr[i].length
 
        for (let j = 0; j < len2; j++) {
            console.log(arr[i][j]);
        }
         
    }
}
```
首先，没有悬念，第一行执行了1次；

其次，最内层console执行了 n * n 次

循环体中执行的次数如下图所示：
<img :src="$withBase('/images/data/data.png')" alt="foo">

那么，总数为：
```js
T(n) = 1 + 1 + (n + 1) + n + n + n + n * (n + 1) + n * n + n * n = 3n^2 + 5n + 3
```
代码的执行次数可以反应出代码执行的时间。但如果每次我们都逐行去计算T(n)，事情会非常麻烦。

算法的时间复杂度，反应的并不是算法的逻辑代码被执行了多少次，而是随着输入规模的增大，算法对应的执行总数的一个变化趋势。想要反应趋势，那就简单多了，尝试对T(n)进行简化，如下：

若T(n)是常数，简化为1；
若T(n)是多项式，如3n^2 + 5n + 3，只保留次数最高的那一项，并将常数转化为1；
经过上面的操作，T(n)简化为O(n):

```js
T(n) = 10
O(n) = 1
 
T(n) = 3n^2 + 5n + 3
O(n) = n^2
```
到这里，我们将程序的每一行执行简化为主要逻辑的执行，从T(n)推算到O(n)，可以看出，计算O(n)基本可以目测

程序中就以大 O 表示复杂度。

其他的时间复杂度：

+ O(1)：常数复杂度
+ O(logn)：对数复杂度
+ O(n)：线性复杂度
+ O(n^2)：平方复杂度
+ O(n^3)：立方复杂度
+ O(2^n)：执行复杂度
+ O(n!)：阶乘复杂度
<img :src="$withBase('/images/data/data1.png')" alt="foo">

#### 空间复杂度
空间复杂度是一个算法在运行过程中临时暂用存储空间大小的度量。和时间复杂度相似，它是内存增长的趋势。

常见的控件复杂度有：O(1)、O(n)、O(n^2)

要理解空间复杂度，还是来看个例子：
```js
function repeat (arr) {
    const len = arr.length;
    for(let i = 0; i < len; i++) {
        console.log(arr[i]);
    }
}
```
在repeat函数中，占用空间的有一下变量：arr、len、i，后面尽管循环了n次，但是这只是时间上的开销，因此repeat函数对应的空间复杂度是：O(1)。

再看一个例子，初始化一个规模为n的数组，并将每个数组的元素值设为索引值，如下：
```js
function repeat (n) {
    const arr = [];
    for(let i = 0; i < n; i++) {
        arr[i] = i
    }
    return arr;
}
```
在repeat中，占用空间用到的变量有：n、arr、i，arr的最终大小有输入的n所决定，它会随着n的增大而增大，呈一个线性关系。因此这个算法的空间复杂度为O(n)。

根据上面的分析，灵活应用就可以计算出每一个算法的时间复杂度和空间复杂度。